"""
Embed Files Build Script for PlatformIO

This script converts web assets from the data/ folder into C header files
with PROGMEM arrays, allowing them to be embedded directly in the firmware.

Files are gzip-compressed where applicable to minimize flash usage.
The hwcfg.json file is excluded as it should remain on the filesystem.
"""

Import("env")
import os
import gzip
import pathlib

# Files to exclude from embedding (these remain on LittleFS)
EXCLUDE_FILES = [
    "hwcfg.json",
]

# File extensions that should be gzip compressed
COMPRESS_EXTENSIONS = ["js", "css", "html", "ico", "eot", "woff", "txt", "json"]

# Content type mapping
CONTENT_TYPES = {
    "html": "text/html",
    "css": "text/css",
    "js": "application/javascript",
    "ico": "image/x-icon",
    "png": "image/png",
    "svg": "image/svg+xml",
    "eot": "application/vnd.ms-fontobject",
    "woff": "application/font-woff",
    "json": "application/json",
    "txt": "text/plain",
    "mel": "text/plain",
}

def get_content_type(filename):
    """Get MIME content type for a file based on its extension."""
    ext = pathlib.Path(filename).suffix[1:].lower()
    return CONTENT_TYPES.get(ext, "application/octet-stream")

def sanitize_name(s):
    """Convert any string to valid C identifier."""
    # Replace all non-alphanumeric characters with underscores
    result = ""
    for c in s:
        if c.isalnum():
            result += c.lower()
        else:
            result += "_"
    # Ensure it starts with a letter or underscore
    if result and result[0].isdigit():
        result = "_" + result
    # Collapse multiple underscores
    while "__" in result:
        result = result.replace("__", "_")
    # Remove trailing underscore
    if result.endswith("_"):
        result = result[:-1]
    return result

def format_byte_array(data, line_width=16):
    """Format binary data as C array initialization."""
    lines = []
    for i in range(0, len(data), line_width):
        chunk = data[i:i + line_width]
        hex_values = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"    {hex_values},")
    return "\n".join(lines)

def generate_embedded_files_header(source, target, env):
    """
    Generate C header file with embedded web assets.
    
    This function is called as a pre-build action by PlatformIO.
    """
    # Get data directory path (remove 'zip' suffix to get actual data dir)
    data_dir = env.get("PROJECT_DATA_DIR")
    if data_dir.endswith("zip"):
        data_dir = data_dir[:-3]
    
    # Output header file path
    src_dir = env.get("PROJECT_SRC_DIR")
    header_path = os.path.join(src_dir, "web_files.h")
    
    print(f"Generating embedded files header from {data_dir}")
    print(f"Output: {header_path}")
    
    # Collect all files to embed
    files_to_embed = []
    
    if not os.path.exists(data_dir):
        print(f"Warning: Data directory {data_dir} does not exist")
        return
    
    for filename in sorted(os.listdir(data_dir)):
        filepath = os.path.join(data_dir, filename)
        
        # Skip directories and excluded files
        if os.path.isdir(filepath):
            continue
        if filename in EXCLUDE_FILES:
            print(f"  Skipping (excluded): {filename}")
            continue
        
        files_to_embed.append((filename, filepath))
    
    # Generate header file content
    header_lines = []
    header_lines.append("/**")
    header_lines.append(" * Auto-generated file - DO NOT EDIT")
    header_lines.append(" * Generated by embed_files.py")
    header_lines.append(" * Contains embedded web assets for serving from PROGMEM")
    header_lines.append(" */")
    header_lines.append("")
    header_lines.append("#ifndef WEB_FILES_H")
    header_lines.append("#define WEB_FILES_H")
    header_lines.append("")
    header_lines.append("#include <Arduino.h>")
    header_lines.append("#include <pgmspace.h>")
    header_lines.append("")
    
    # Generate file data arrays
    file_entries = []
    total_size = 0
    total_compressed_size = 0
    
    for filename, filepath in files_to_embed:
        ext = pathlib.Path(filename).suffix[1:].lower()
        should_compress = ext in COMPRESS_EXTENSIONS
        content_type = get_content_type(filename)
        
        # Read file content
        with open(filepath, "rb") as f:
            original_data = f.read()
        
        original_size = len(original_data)
        total_size += original_size
        
        # Compress if applicable
        if should_compress:
            compressed_data = gzip.compress(original_data, compresslevel=9)
            data_to_embed = compressed_data
            is_gzipped = True
            var_name = f"file_{sanitize_name(filename)}_gz"
        else:
            data_to_embed = original_data
            is_gzipped = False
            var_name = f"file_{sanitize_name(filename)}"
        
        embedded_size = len(data_to_embed)
        total_compressed_size += embedded_size
        
        compression_ratio = (1 - embedded_size / original_size) * 100 if original_size > 0 else 0
        print(f"  {filename}: {original_size} -> {embedded_size} bytes ({compression_ratio:.1f}% saved)")
        
        # Generate array declaration
        header_lines.append(f"// File: {filename} ({embedded_size} bytes, {'gzipped' if is_gzipped else 'raw'})")
        header_lines.append(f"const uint8_t {var_name}[] PROGMEM = {{")
        header_lines.append(format_byte_array(data_to_embed))
        header_lines.append("};")
        header_lines.append(f"const size_t {var_name}_len = {embedded_size};")
        header_lines.append("")
        
        # Add to file entries list
        # Web path should start with /
        web_path = f"/{filename}"
        file_entries.append({
            "path": web_path,
            "var_name": var_name,
            "size": embedded_size,
            "content_type": content_type,
            "is_gzipped": is_gzipped,
        })
    
    # Generate file registry structure
    header_lines.append("// Embedded file registry structure")
    header_lines.append("struct EmbeddedFile {")
    header_lines.append("    const char* path;")
    header_lines.append("    const uint8_t* data;")
    header_lines.append("    size_t size;")
    header_lines.append("    const char* contentType;")
    header_lines.append("    bool isGzipped;")
    header_lines.append("};")
    header_lines.append("")
    
    # Generate path strings in PROGMEM
    header_lines.append("// File paths in PROGMEM")
    for entry in file_entries:
        path_var = f"path_{sanitize_name(entry['path'][1:])}"
        header_lines.append(f"const char {path_var}[] PROGMEM = \"{entry['path']}\";")
    header_lines.append("")
    
    # Generate content type strings in PROGMEM
    header_lines.append("// Content types in PROGMEM")
    unique_content_types = list(set(e["content_type"] for e in file_entries))
    for ct in unique_content_types:
        ct_var = f"ct_{sanitize_name(ct)}"
        header_lines.append(f"const char {ct_var}[] PROGMEM = \"{ct}\";")
    header_lines.append("")
    
    # Generate file registry array
    header_lines.append(f"// File registry ({len(file_entries)} files)")
    header_lines.append(f"const size_t EMBEDDED_FILES_COUNT = {len(file_entries)};")
    header_lines.append("")
    header_lines.append("const EmbeddedFile EMBEDDED_FILES[] PROGMEM = {")
    
    for entry in file_entries:
        path_var = f"path_{sanitize_name(entry['path'][1:])}"
        ct_var = f"ct_{sanitize_name(entry['content_type'])}"
        gzipped_str = "true" if entry["is_gzipped"] else "false"
        header_lines.append(f"    {{{path_var}, {entry['var_name']}, {entry['size']}, {ct_var}, {gzipped_str}}},")
    
    header_lines.append("};")
    header_lines.append("")
    
    # Generate helper function to find embedded file
    header_lines.append("/**")
    header_lines.append(" * Find an embedded file by path")
    header_lines.append(" * @param path The URL path to search for (e.g., \"/index.html\")")
    header_lines.append(" * @return Pointer to EmbeddedFile struct, or nullptr if not found")
    header_lines.append(" */")
    header_lines.append("inline const EmbeddedFile* findEmbeddedFile(const String& path) {")
    header_lines.append("    for (size_t i = 0; i < EMBEDDED_FILES_COUNT; i++) {")
    header_lines.append("        char pathBuf[64];")
    header_lines.append("        strncpy_P(pathBuf, (PGM_P)pgm_read_ptr(&EMBEDDED_FILES[i].path), sizeof(pathBuf) - 1);")
    header_lines.append("        pathBuf[sizeof(pathBuf) - 1] = '\\0';")
    header_lines.append("        if (path.equals(pathBuf)) {")
    header_lines.append("            return &EMBEDDED_FILES[i];")
    header_lines.append("        }")
    header_lines.append("    }")
    header_lines.append("    return nullptr;")
    header_lines.append("}")
    header_lines.append("")
    header_lines.append("#endif // WEB_FILES_H")
    header_lines.append("")
    
    # Write header file
    with open(header_path, "w") as f:
        f.write("\n".join(header_lines))
    
    print(f"Generated {header_path}")
    print(f"Total: {len(file_entries)} files, {total_size} bytes -> {total_compressed_size} bytes")
    print(f"Overall compression: {(1 - total_compressed_size / total_size) * 100:.1f}% saved")

# Run generation immediately at script load time (every build)
# This ensures web_files.h is always up-to-date before compilation starts
generate_embedded_files_header(None, None, env)
